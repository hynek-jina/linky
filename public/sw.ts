/// <reference lib="es2020" />
/// <reference lib="dom" />
/// <reference lib="webworker" />

import { precacheAndRoute } from "workbox-precaching";
import { registerRoute, NavigationRoute } from "workbox-routing";
import { CacheFirst } from "workbox-strategies";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { ExpirationPlugin } from "workbox-expiration";

// Precache all assets generated by the build process
// @ts-ignore: injected by workbox-build
declare const self: ServiceWorkerGlobalScope;

precacheAndRoute(self.__WB_MANIFEST || []);

// Cache images
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "linky-runtime-images-v1",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 256,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Navigation route - serve index.html for all navigations
registerRoute(
  new NavigationRoute(
    // @ts-ignore: workbox types
    async () => {
      const cache = await caches.open("workbox-precache-v2");
      const response = await cache.match("/index.html");
      return response || fetch("/index.html");
    },
    {
      allowlist: [/^\/$/],
    }
  )
);

// Push event handler - receive push notifications
self.addEventListener("push", (event) => {
  console.log("[SW] Push event received!", event);
  
  if (!event.data) {
    console.log("[SW] No data in push event");
    return;
  }

  try {
    const data = event.data.json();
    console.log("[SW] Push data:", data);

    const contactNpub = data.data?.contactNpub;
    const title = data.title || "Nová zpráva";
    
    // Show initial notification immediately
    const options: NotificationOptions = {
      body: data.body || "Máš novou zprávu v Linky",
      icon: "/pwa-192x192.png",
      badge: "/pwa-192x192.png",
      tag: contactNpub || "linky-message",
      requireInteraction: false,
      data: data.data || { type: "dm" },
    };

    console.log("[SW] Showing initial notification:", title, options);
    
    // Show notification immediately
    const showNotification = self.registration.showNotification(title, options);
    
    // Update badge count on app icon (iOS support)
    if ("setAppBadge" in navigator) {
      navigator.setAppBadge().catch((err: unknown) => {
        console.error("[SW] Error setting badge:", err);
      });
    }
    
    // Try to get decrypted content from the app
    if (contactNpub) {
      const updateNotification = self.clients.matchAll({ type: "window", includeUncontrolled: true })
        .then(clients => {
          if (clients.length > 0) {
            // Send message to app to decrypt the latest message
            clients.forEach(client => {
              client.postMessage({
                type: "GET_MESSAGE_CONTENT",
                contactNpub: contactNpub,
                notificationTag: contactNpub,
              });
            });
          }
        })
        .catch(err => console.error("[SW] Error contacting clients:", err));
      
      event.waitUntil(Promise.all([showNotification, updateNotification]));
    } else {
      event.waitUntil(showNotification);
    }
  } catch (error) {
    console.error("[SW] Error showing notification:", error);
  }
});

// Listen for messages from the app
self.addEventListener("message", (event) => {
  console.log("[SW] Received message from app:", event.data);
  
  if (event.data.type === "UPDATE_NOTIFICATION") {
    const { title, body, tag, language } = event.data;
    
    // Localize based on language
    const localizedTitle = title;
    const localizedBody = body;
    
    // Update the notification
    self.registration.showNotification(localizedTitle, {
      body: localizedBody,
      icon: "/pwa-192x192.png",
      badge: "/pwa-192x192.png",
      tag: tag,
      requireInteraction: false,
      data: { type: "dm", contactNpub: tag },
      renotify: true, // Replace existing notification with same tag
    }).then(() => {
      console.log("[SW] Notification updated with decrypted content");
    }).catch(err => {
      console.error("[SW] Error updating notification:", err);
    });
  }
});

// Notification click handler - open app when user clicks notification
self.addEventListener("notificationclick", (event) => {
  event.notification.close();

  const data = event.notification.data;
  let url = "/";

  if (data?.type === "dm" && data?.contactNpub) {
    url = `/#/chat/${encodeURIComponent(data.contactNpub)}`;
  }

  // Clear badge when user clicks notification
  if ("clearAppBadge" in navigator) {
    navigator.clearAppBadge().catch((err: unknown) => {
      console.error("[SW] Error clearing badge:", err);
    });
  }

  event.waitUntil(
    self.clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((clientList) => {
        // If a window client is already open, focus it
        for (const client of clientList) {
          if (client.url && "focus" in client) {
            return client.navigate(url).then(() => client.focus());
          }
        }
        // Otherwise open a new window
        if (self.clients.openWindow) {
          return self.clients.openWindow(url);
        }
      })
  );
});

// Skip waiting and claim clients immediately
self.addEventListener("install", () => {
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});
